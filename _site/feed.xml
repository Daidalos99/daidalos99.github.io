<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>daidalos99</title>
    <description>daidalos99&apos;s code vault</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>2024-03-31</pubDate>
    <lastBuildDate>Sun, 31 Mar 2024 23:28:40 +0900</lastBuildDate>
    <generator>Jekyll v3.9.5</generator>
    
      <item>
        <title>Welcome to Jekyll!</title>
        <description>&lt;p&gt;You’ll find this post in your &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;Jekyll requires blog post files to be named according to the following format:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;YEAR-MONTH-DAY-title.MARKUP&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;YEAR&lt;/code&gt; is a four-digit number, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MONTH&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DAY&lt;/code&gt; are both two-digit numbers, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MARKUP&lt;/code&gt; is the file extension representing the format used in the file. After that, include the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;Tom&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints &apos;Hi, Tom&apos; to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;https://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;

</description>
        <pubDate>2024-03-31</pubDate>
        <link>http://localhost:4000/articles/2024-03/welcome-to-jekyll</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2024-03/welcome-to-jekyll</guid>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
      <item>
        <title>move_base</title>
        <description>&lt;h2 id=&quot;move_base-패키지와-파라미터-공부&quot;&gt;move_base 패키지와 파라미터 공부&lt;/h2&gt;

&lt;p&gt;rbiz 푸드 딜리버리 챌린지를 준비하면서 오랜만에 move_base를 써보게 되었는데, 오랜만에 보니 헷갈리기도 헷갈리고 뭐가 뭔지 모르겠는 느낌이었다. 그래서 공부한 내용을 정리하기로 했다.&lt;/p&gt;

&lt;p&gt;혹시 몰라 적어두는 나의 SLAM &amp;amp; Navigation 실행환경은 아래와 같다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Ubuntu 20.04.6 LTS Focal Fossa&lt;/li&gt;
  &lt;li&gt;ROS Noetic&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;move_base란&quot;&gt;move_base란?&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://wiki.ros.org/move_base&quot;&gt;move_base&lt;/a&gt; 노드는 (모바일)로봇의 navigation stack과 상호작용하기 위한 ROS 인터페이스(토픽, 서비스, 액션, 파라미터)를 제공한다. 아래 그림(화이트 테마를 키고 보자.)은 일반적인 모바일 로봇의 navigation stack 설정을 나타낸 그림이고, 그 중에서도 가운데 네모가 move_base 노드의 구조를 나타낸다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/project/rbiz/move_base/move_base.png&quot; alt=&quot;move_base&quot; /&gt;&lt;/p&gt;

&lt;p&gt;파란색 부분은 로봇(플랫폼)에 따라 달라질 수 있는 부분이고, 회색 부분은 부가적이지만, 모든 시스템을 위해 제공된다. move_base 노드는 이러한 시스템 및 부가적으로 발행되는 정보들과 맞물려서, &lt;strong&gt;로봇이 목적 자세(goal pose)를 달성할수 있도록&lt;/strong&gt; 한다.&lt;/p&gt;

&lt;p&gt;아무튼, move_base 부분만 보면&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;global_planner&lt;/li&gt;
  &lt;li&gt;global_costmap&lt;/li&gt;
  &lt;li&gt;local_planner&lt;/li&gt;
  &lt;li&gt;local_costmap&lt;/li&gt;
  &lt;li&gt;recovery_behaviors&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;로 구성되어 있다.&lt;/p&gt;

&lt;p&gt;우선 &lt;strong&gt;Costmap&lt;/strong&gt;이란 것은 grid cell로 구성되어 있는 지도(occupancy grid map)에서 각 셀들이 장애물/지형의 특성 등을 반영한 cost 값을 가지는 것이다.&lt;/p&gt;

&lt;h2 id=&quot;recovery-behavior&quot;&gt;Recovery Behavior&lt;/h2&gt;
&lt;p&gt;move_base의 Recovery Behavior 시행 순서는 아래 그림과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/project/rbiz/move_base/expected_behaviors.png&quot; alt=&quot;expected_behavior&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;사용자가 설정한 영역외의 장애물들을 로봇의 지도에서 제거한다.&lt;/li&gt;
  &lt;li&gt;가능하다면, 로봇은 영역을 초기화하기 위해 제자리 회전 수행한다.&lt;/li&gt;
  &lt;li&gt;위 과정이 실패하면, 로봇은 모든 장애물들을 제자리 회전이 가능한 사각형 밖으로 제거해버린다. 그리고 또다른 제자리회전을 수행한다.&lt;/li&gt;
  &lt;li&gt;만약 죄다 실패한다면, 목표가 도달불가능한지 고려한 후, 그에 따른 보류 메세지를 출력한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;파라미터-파일yaml-설정&quot;&gt;파라미터 파일(yaml) 설정&lt;/h2&gt;
&lt;p&gt;move_base의 launch파일을 보면, rosparam으로 여러 yaml파일을 설정해준다. 대략적인 파일은 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;move_base_only.launch  

&lt;span class=&quot;nt&quot;&gt;&amp;lt;launch&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;node&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;pkg=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;move_base&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;move_base&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;respawn=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;false&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;move_base&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;output=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;screen&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;rosparam&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;file=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;$(find pkg)/params/costmap_common_params.yaml&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;command=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;load&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;ns=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;global_costmap&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;rosparam&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;file=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;$(find pkg)/params/costmap_common_params.yaml&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;command=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;load&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;ns=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;local_costmap&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;rosparam&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;file=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;$(find pkg)/params/map_nav_params/local_costmap_params.yaml&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;command=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;load&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;rosparam&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;file=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;$(find pkg)/params/map_nav_params/global_costmap_params.yaml&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;command=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;load&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;rosparam&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;file=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;$(find pkg)/params/base_local_planner_params.yaml&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;command=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;load&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;rosparam&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;file=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;$(find pkg)/params/move_base_params.yaml&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;command=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;load&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;param&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;base_global_planner&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;string&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;navfn/NavfnROS&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;param&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;base_local_planner&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;base_local_planner/TrajectoryPlannerROS&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;	
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;param&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;clearing_rotation_allowed&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!--remap from=&quot;odom&quot; to=&quot;/odometry/filtered&quot; /--&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/node&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/launch&amp;gt;&lt;/span&gt;  

위 경로는 본인의 경로에 맞춘 것이므로, 각 yaml파일들의 경로는 사람마다 다를 수 있음.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;rosparam으로 선언된 파라미터들을 보면, 총 5개의 launch파일들을 태그하고 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;costmap_common_params.yaml&lt;/li&gt;
  &lt;li&gt;local_cost_params.yaml&lt;/li&gt;
  &lt;li&gt;global_cost_params.yaml&lt;/li&gt;
  &lt;li&gt;base_local_planner.yaml&lt;/li&gt;
  &lt;li&gt;move_base_params.yaml&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;costmap-configuration&quot;&gt;Costmap Configuration&lt;/h3&gt;
&lt;p&gt;Navigation stack에서는 장애물 정보가 담긴 2개의 costmap을 사용한다. 하나는 global planning(전체 환경에서의 계획)에 사용되는 &lt;strong&gt;global costmap&lt;/strong&gt;, 다른 하나는 local planning과 장애물 회피에 사용되는 &lt;strong&gt;local costmap&lt;/strong&gt; 이다.&lt;/p&gt;

&lt;p&gt;이 두 costmap에 관한 설정을 해줘야 할텐데, global, local costmap이 공통으로 적용되는 설정은 &lt;strong&gt;costmap_common_params.yaml&lt;/strong&gt;에, 각각의 설정은 &lt;strong&gt;local_cost_params.yaml&lt;/strong&gt;, &lt;strong&gt;global_cost_params.yaml&lt;/strong&gt;에 담겨있다. 여기서는 중요한, 그리고 내가 사용한 파라미터 위주로 간단히 훑을 것이다.&lt;/p&gt;

&lt;p&gt;우선 &lt;strong&gt;costmap_common_params.yaml&lt;/strong&gt;부터 보자.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;#---standard pioneer footprint---&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#---(in meters)---&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;footprint&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;-0.3&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;-0.25&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;-0.3&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;0.25&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;0.3&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;0.25&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;0.3&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;-0.25&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;]]&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;footprint_padding&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.03&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Acceptable errors in the robot&apos;s sensor data or in areas related to positional transformation&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;transform_tolerance&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;map_type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;costmap&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;always_send_full_costmap&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;obstacle_layer&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
 &lt;span class=&quot;na&quot;&gt;enabled&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
 &lt;span class=&quot;na&quot;&gt;obstacle_range&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2.0&lt;/span&gt;
 &lt;span class=&quot;na&quot;&gt;raytrace_range&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4.0&lt;/span&gt;
 &lt;span class=&quot;na&quot;&gt;inflation_radius&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.2&lt;/span&gt;
 &lt;span class=&quot;na&quot;&gt;track_unknown_space&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
 &lt;span class=&quot;na&quot;&gt;combination_method&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
 &lt;span class=&quot;na&quot;&gt;observation_sources&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;scan&lt;/span&gt;
 &lt;span class=&quot;na&quot;&gt;scan&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;sensor_frame&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;base_link&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;data_type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;LaserScan&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;topic&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;/scan_filtered&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;marking&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;clearing&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;inflation_layer&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;enabled&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;              &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;cost_scaling_factor&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;m&quot;&gt;10.0&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# exponential rate at which the obstacle cost drops off (default: 10)&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;inflation_radius&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;m&quot;&gt;0.3&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 0.5, max. distance from an obstacle at which costs are incurred for planning paths.&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;static_layer&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;enabled&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;              &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;map_topic&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;            &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;/map&quot;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;footprint: 로봇의 바운더리 설정, 점을 하나씩 추가 할때마다, 로봇의 바운더리 다각형의 꼭짓점 수가 늘어남&lt;/li&gt;
  &lt;li&gt;footprint_padding: footprint의 여유공간, 로봇이 충돌하지 않기 위해 여유공간(패딩)을 주는 것&lt;/li&gt;
  &lt;li&gt;transform_tolerance: 로봇의 위치변환(tf)에 대한 허용 오차, 로봇의 현재 위치와 센서 데이터간의 차이가 이 값 이내로 허용됨&lt;/li&gt;
  &lt;li&gt;obstacle_range: costmap 상에서 장애물을 인지할 최대 거리를 의미함&lt;/li&gt;
  &lt;li&gt;raytrace_range: 주어진 센서값으로 얼마나 탐지 및 초기화할 것인지에 대한 거리&lt;/li&gt;
  &lt;li&gt;inflation_radius: 장애물 주변 팽창(패딩) 거리, 로봇이 장애물에 가까이 다가가지 않도록 해줌&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;정도가 있다.&lt;/p&gt;

&lt;p&gt;다음은 &lt;strong&gt;local_costmap_params.yaml&lt;/strong&gt;이다.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;local_costmap&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;global_frame&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;odom&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# map&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;robot_base_frame&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;base_link&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;update_frequency&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5.0&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;publish_frequency&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2.0&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;static_map&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;rolling_window&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4.5&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4.5&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;resolution&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.05&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;transform_tolerance&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.3&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;inflation_radius&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;m&quot;&gt;0.1&lt;/span&gt;
  
  &lt;span class=&quot;na&quot;&gt;plugins&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
   &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;static_layer&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;,&lt;/span&gt;        &lt;span class=&quot;nv&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;costmap_2d::StaticLayer&quot;&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;obstacle_layer&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;,&lt;/span&gt;      &lt;span class=&quot;nv&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;costmap_2d::ObstacleLayer&quot;&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;inflation_layer&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;,&lt;/span&gt;     &lt;span class=&quot;nv&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;costmap_2d::InflationLayer&quot;&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;global_frame: costmap이 실행되는 기준 좌표계&lt;/li&gt;
  &lt;li&gt;update_frequency: costmap 갱신 주기(Hz)&lt;/li&gt;
  &lt;li&gt;publish_frequency: costmap의 시각화(visulization) 퍼블리시 주기(Hz)&lt;/li&gt;
  &lt;li&gt;static_map: costmap이 외부에서 (저장된)지도를 (map_server를 사용해서)가져오는지 여부&lt;/li&gt;
  &lt;li&gt;rolling_window: 로봇이 전진할 때, costmap이 로봇을 중심으로 하는지 여부&lt;/li&gt;
  &lt;li&gt;width, height, resolution(meters/cell): costmap의 너비, 높이, 해상도 설정, 해상도는 사용하는 static map의 해상도(map.yaml??)과 달라도 괜찮으나, 보통 동일하게 설정&lt;/li&gt;
  &lt;li&gt;transform_tolerance, inflation_radius는 위와 동일&lt;/li&gt;
  &lt;li&gt;plugins: local_costmap에 적용할 레이어(플러그인)을 설정하는 부분
    &lt;ul&gt;
      &lt;li&gt;static_layer: 정적 맵 레이어, 외부에서 제공되는 지도정보를 기반으로 만들어진 costmap layer&lt;/li&gt;
      &lt;li&gt;obstacle_layer: 로봇 주변 장애물 기반 costmap layer&lt;/li&gt;
      &lt;li&gt;inflation_layer: 장애물 주변의 cost를 높인 팽창 layer&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이어서 &lt;strong&gt;global_costmap_params.yaml&lt;/strong&gt;이다.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;global_costmap&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;global_frame&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;/map&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;robot_base_frame&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;base_link&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;update_frequency&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5.0&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;publish_frequency&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.5&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;static_map&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;transform_tolerance&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.3&lt;/span&gt;

  &lt;span class=&quot;na&quot;&gt;plugins&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;static_layer&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;,&lt;/span&gt;            &lt;span class=&quot;nv&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;costmap_2d::StaticLayer&quot;&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;obstacle_layer&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;,&lt;/span&gt;          &lt;span class=&quot;nv&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;costmap_2d::VoxelLayer&quot;&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;inflation_layer&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;,&lt;/span&gt;         &lt;span class=&quot;nv&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;costmap_2d::InflationLayer&quot;&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이미 위에서 다 언급된 파라미터이기 때문에 따로 설명하지 않는다. 위에서 정리한 파라미터들은 &lt;a href=&quot;http://wiki.ros.org/navigation/Tutorials/RobotSetup#Costmap_Configuration_.28local_costmap.29_.26_.28global_costmap.29&quot;&gt;Navigation Configuration ROS Wiki&lt;/a&gt;를 기반으로 작성하였다. 전체 costmap 옵션 대한 설명은 &lt;a href=&quot;http://wiki.ros.org/costmap_2d&quot;&gt;costmap_2d ROS Wiki&lt;/a&gt;를 참고하면 된다.&lt;/p&gt;

&lt;h3 id=&quot;base-local-planner-configuration&quot;&gt;Base Local Planner Configuration&lt;/h3&gt;
&lt;p&gt;base_local_planner는 로봇의 베이스의 속도 명령을 계산하는 역할을 한다, 즉 평면상에서 모바일 베이스를 구동하는 컨트롤러를 제공한다. planner는 각 경로에 해당하는 grid cell들의 cost가 최소가 되도록 경로를 생성한다. 다음은 예시가 되는 DWA 알고리즘의 그림이다.
&lt;img src=&quot;/assets/img/project/rbiz/move_base/local_plan.png&quot; alt=&quot;dwa&quot; /&gt;&lt;/p&gt;

&lt;p&gt;base_local_planner에 대한 더 자세한 설명은 &lt;a href=&quot;http://wiki.ros.org/base_local_planner&quot;&gt;base_local_planner ROS Wiki&lt;/a&gt;를 참고하자.&lt;br /&gt;
base_local_planner 파라미터는 당연히 사용자가 가지고 있는 로봇의 스펙에 맞춰 작성해야 한다.&lt;/p&gt;

&lt;p&gt;다음은 나의 &lt;strong&gt;base_local_planner.yaml&lt;/strong&gt;파일이다.&lt;/p&gt;
&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;TrajectoryPlannerROS&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# 로봇의 속도에 관한 파라미터&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;max_vel_x&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;2.0&lt;/span&gt; 
  &lt;span class=&quot;na&quot;&gt;min_vel_x&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.1&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;max_vel_theta&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1.0&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;min_vel_theta&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;-1.0&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;min_in_place_vel_theta&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1.0&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;# 로봇의 가속도에 관한 파라미터&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;acc_lim_x&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3.0&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;acc_lim_theta&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;m&quot;&gt;2.5&lt;/span&gt;

  &lt;span class=&quot;na&quot;&gt;holonomic_robot&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;escape_vel&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;-0.2&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;# 목표지점 도달 허용범위&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;yaw_goal_tolerance&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.157&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;xy_goal_tolerance&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.25&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;latch_xy_goal_tolerance&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;# 전방 시뮬레이션 파라미터&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;sim_time&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1.0&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;sim_granularity&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.02&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;angular_sim_granularity&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.02&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;vx_samples&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;6&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;vtheta_samples&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;20&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;controller_frequency&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;20.0&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;# Trajectory scoring parameters&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;meter_scoring&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# Whether the gdist_scale and pdist_scale parameters should assume that goal_distance and path_distance are expressed in units of meters or cells. Cells are assumed by default (false).&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;occdist_scale&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;m&quot;&gt;0.1&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#The weighting for how much the controller should attempt to avoid obstacles. default 0.01&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;path_dist_scale_bias&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2.5&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;#     The weighting for how much the controller should stay close to the path it was given . default 0.6&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;goal_dist_scale_bias&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1.0&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#     The weighting for how much the controller should attempt to reach its local goal, also controls speed  default 0.8&lt;/span&gt;

  &lt;span class=&quot;na&quot;&gt;heading_lookahead&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.1&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;#How far to look ahead in meters when scoring different in-place-rotation trajectories&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;heading_scoring&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;#Whether to score based on the robot&apos;s heading to the path or its distance from the path. default false&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;heading_scoring_timestep&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.8&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;#How far to look ahead in time in seconds along the simulated trajectory when using heading scoring (double, default: 0.8)&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;dwa&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#Whether to use the Dynamic Window Approach (DWA)_ or whether to use Trajectory Rollout&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;simple_attractor&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;publish_cost_grid_pc&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;#Oscillation Prevention Parameters&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;oscillation_reset_dist&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.25&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#How far the robot must travel in meters before oscillation flags are reset (double, default: 0.05)&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;escape_reset_dist&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.1&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;escape_reset_theta&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.1&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# BaseGlobalPlanner:&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#   allow_unknown: false&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#   use_dijkstra: false #Use A* instead&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#   use_quadratic: true&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#   use_grid_path: false&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#   old_navfn_behavior: false&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;간단한 파라미터는 주석을 달아놓았으며, 그 외 설명은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;holonomic_robot: holonomic 로봇 기반 속도명령을 생성할지 여부&lt;/li&gt;
  &lt;li&gt;escape_vel: 로봇의 탈출 속도(m/s), 로봇이 실제로 후진해서 탈출하기 위해서는 음수값이어야 함&lt;/li&gt;
  &lt;li&gt;sim_time: 궤적을 전방 시뮬레이션하는데 걸리는 시간&lt;/li&gt;
  &lt;li&gt;sim_granularity: 주어진 궤적에서 점 사이 간격(m)&lt;/li&gt;
  &lt;li&gt;vx_sample: x속도 공간을 탐사할때 사용하는 샘플의 개수&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;등이고, 모든 파라미터에 대한 설명은 &lt;a href=&quot;http://wiki.ros.org/base_local_planner#TrajectoryPlannerROS&quot;&gt;base_local_planner ROS Wiki&lt;/a&gt;를 참고하자.&lt;/p&gt;

&lt;h3 id=&quot;move_base-configuration&quot;&gt;move_base configuration&lt;/h3&gt;
&lt;p&gt;마지막으로, &lt;strong&gt;move_base_params.yaml&lt;/strong&gt;에 관한 설명이다.&lt;/p&gt;
&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;shutdown_costmaps&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;controller_frequency&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;20.0&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;controller_patience&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;15.0&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;planner_frequency&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;20.0&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;planner_patience&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5.0&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;oscillation_timeout&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.0&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;oscillation_distance&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.5&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;recovery_behavior_enabled&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;clearing_rotation_allowed&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# true, 로봇이 회전을 통해 효과적으로 장애물을 제거하거나 회피할 수 있다면 true로 설정하는 것이 좋을 수 있습니다&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;shutdown_costmaps: move_base가 비활성화 상태일때 costmap도 중지할 것인지 여부&lt;/li&gt;
  &lt;li&gt;controller_frequency: 로봇 베이스에 속도 명령을 전달하는 주기 및 제어 주기(Hz)&lt;/li&gt;
  &lt;li&gt;controller_patience: 공간 초기화 작업을 수행하기 전에 컨트롤러가 제어를 받지 않고 몇초간 기다릴 것인가&lt;/li&gt;
  &lt;li&gt;planner_frequency: global planning loop를 수행하기 위한 주기(Hz), 0.0으로 설정 시, 새로운 goal을 받거나 local planner가 경로가 막혔다고 판단하는 경우에만 global planner가 동작&lt;/li&gt;
  &lt;li&gt;planner_patience: planner가 공간 초기화 작업을 수행하기 전 유요한 계획을 찾기 위해 몇초간 기다릴 것인가&lt;/li&gt;
  &lt;li&gt;oscillation_timeout: 복구 동작을 실행하기 전 진동을 허용하는 시간(초), 0.0으로 설정 시 infinite timeout&lt;/li&gt;
  &lt;li&gt;oscillation_distance: 로봇이 진동하지 않는다고 간주되기 위해 얼마나 움직여야 하는지(m)&lt;/li&gt;
  &lt;li&gt;recovery_behavior_enabled: 공간을 초기화하기 위해서 move_base 복구 동작(recovery behavior)를 사용할 것인지 여부&lt;/li&gt;
  &lt;li&gt;clearing_rotation_allowed: 로봇이 공간을 초기화하기 위해 제자리 회전을 시도할 것인지 여부, 로봇이 회전을 통해 효과적으로 장애물을 제거하거나 회피할 수 있다면 true로 설정&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;move_base_params에 대한 모든 파라미터 설명은 &lt;a href=&quot;http://wiki.ros.org/move_base#Parameters&quot;&gt;move_base ROS Wiki&lt;/a&gt;를 참고하자.&lt;/p&gt;

</description>
        <pubDate>2024-03-31</pubDate>
        <link>http://localhost:4000/articles/2023-08/move_base</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2023-08/move_base</guid>
        
        <category>ROS</category>
        
        <category>move_base</category>
        
        <category>SLAM</category>
        
        <category>navigation</category>
        
        
        <category>project</category>
        
        <category>rbiz</category>
        
      </item>
    
      <item>
        <title>R-Biz Introduction</title>
        <description>&lt;h2 id=&quot;r-biz-introduction&quot;&gt;R-Biz Introduction&lt;/h2&gt;

&lt;p&gt;이번 여름방학때 듣는 교육을 필두로, 한국로봇산업협회에서 주최하는 &lt;a href=&quot;https://www.korearobot.or.kr/wp/2023/08/03/2023-r-biz-%EC%B1%8C%EB%A6%B0%EC%A7%80-%EC%B0%B8%EA%B0%80%EC%9E%90-%EB%AA%A8%EC%A7%91-%EA%B3%B5%EA%B3%A0%EB%AA%A8%EC%A7%91-%EA%B8%B0%EA%B0%84-%EC%97%B0%EC%9E%A5/&quot;&gt;R-Biz Challenge&lt;/a&gt;에 나가게 되었다.&lt;/p&gt;

&lt;p&gt;우주 탐사 개발 로봇 챌린지, 배달의 민족 로봇 배달 챌린지, 자율주행 챌린지가 있는데, 나는 이중에 배달의 민족(푸드 딜리버리) 챌린지에 참여하게 되었다.&lt;/p&gt;

&lt;p&gt;이 게시판에는 이 챌린지에 관련한 글들을 게시하고자 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/project/rbiz/rbiz_poseter.png&quot; alt=&quot;rbiz_poster&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>2024-03-31</pubDate>
        <link>http://localhost:4000/articles/2023-08/rbiz_introduction</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2023-08/rbiz_introduction</guid>
        
        <category>rbiz</category>
        
        <category>대회</category>
        
        
        <category>project</category>
        
        <category>rbiz</category>
        
      </item>
    
      <item>
        <title>우분투에서 노트북 팬 돌리기(nbfc)</title>
        <description>&lt;h2 id=&quot;우분투에서-노트북-팬-돌리기-및-속도-조절-nbfc&quot;&gt;우분투에서 노트북 팬 돌리기 및 속도 조절 (nbfc)&lt;/h2&gt;

&lt;p&gt;나는 Gigabyte사의 Aero 15SB 노트북 모델을 사용중이다. &lt;br /&gt;
이번 방학에 우연히 Morai Simulator를 접해볼 기회를 얻게 되었는데, 이 시뮬레이션은 상당한 GPU를 필요로 하였다.&lt;br /&gt;
다행이 내 노트북은 gtx 1660ti라는 명기를 가지고 있어 어느정도 버텨 주었지만, 우분투에서는 팬 속도조절이 안돼고, 내 경우에는 팬이 원하는데로 돌아가지 않아서 발열이 심했고, 그럴때마다 프로그램이 종료되었다.&lt;/p&gt;

&lt;p&gt;그래서 열심이 구글링을 한 결과, 깃허브에 &lt;strong&gt;hirschmann&lt;/strong&gt;이라는 사람(독일사람…?)이 만든 &lt;strong&gt;nbfc&lt;/strong&gt;(&lt;strong&gt;N&lt;/strong&gt;ote&lt;strong&gt;B&lt;/strong&gt;ook &lt;strong&gt;F&lt;/strong&gt;an &lt;strong&gt;C&lt;/strong&gt;ontrol)라는 프로그램이 내 노트북에 효과가 있음을 알게 되었다.&lt;/p&gt;

&lt;p&gt;나는 Ubuntu 20.04.6 LTS를 사용하지만, 윈도우나 타 리눅스에서도 가능한 것 같다.&lt;/p&gt;

&lt;p&gt;근데 이게 굉장히 좋은데 반해, 한국 사용자가 정리해놓은 게시물은 별로 없고, 우분투에서의 사용법도 제대로 적혀있지 않아, 원본 github를 보아야 하는데, 영어를 어려워 하는 분들이 쉽게 따라할 수 있도록 내가 프로그램을 사용한 방법을 적어본다.&lt;/p&gt;

&lt;p&gt;사용 전 알아야할 게 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;이 프로그램은 삼성/LG등 국내 제조사의 노트북은 지원되지 않는다.&lt;/li&gt;
  &lt;li&gt;Asus, Acer, Dell, HP, Lenovo, Gigabyte… 등등의 서양 및 대만, 기타 유명한 제조사에서 만든 웬만한 노트북 종은 지원하는 것 같다.(듣보 제조사는 당연히 안됌)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;어쨌거나 이제 이 nbfc라는 프로그램을 사용해 보자. 깃허브 리포지토리 주소는 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/hirschmann/nbfc/tree/master&quot;&gt;https://github.com/hirschmann/nbfc/tree/master&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;여기서 Configs에 들어가면 아래와 같이 여러 노트북 모델들을 확인할 수 있는데, 자신의 노트북 모델이 없다면 자신의 노트북과 비슷한 모델명을 찾아서 사용해보면 될 가능성이 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/etc/nbfc/nbfc_config.JPG&quot; alt=&quot;nbfc_config&quot; /&gt;&lt;/p&gt;

&lt;p&gt;나의 경우 Gigabyte Aero 15SB인데, 그나마 비슷한 Gigabyte AERO 14KV8.xml이 있어서 이 파일을 적용했다.&lt;br /&gt;
아무튼, 비슷한 모델명이 보이면 그 모델명을 외워두고, 쫌이따 사용할 것이다.&lt;/p&gt;

&lt;p&gt;이제부터 잘 따라하면 된다.&lt;br /&gt;
우선 이 리포지토리를 클론하자. (일단 위치는 상관 없음)&lt;/p&gt;

&lt;p&gt;이제, nbfc를 빌드하기 위해서 &lt;strong&gt;mono&lt;/strong&gt;라는 패키지를 설치해야 한다.&lt;br /&gt;
터미널 창에서 아래 명령어를 따라하자.(이번에도 경로는 상관x)&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 3FA7E0328081BFF6A14DA29AA6A19B38D3D831EF
echo &quot;deb https://download.mono-project.com/repo/ubuntu stable-bionic main&quot; | sudo tee /etc/apt/sources.list.d/mono-official-stable.list
sudo apt update
sudo apt install mono-complete
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;만약 타 운영체제에서 nbfc를 사용하고 싶다면, &lt;a href=&quot;https://github.com/hirschmann/nbfc/wiki/How-to-build-NBFC#build-on-linux&quot;&gt;이 링크&lt;/a&gt;를 참고하여 빌드하자.&lt;/p&gt;

&lt;p&gt;어쨌거나 위 명령어를 다 입력한 후, 다운받은 nbfc폴더에서 터미널을 켠 후 아래 명령어를 입력하여 빌드하자.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./build.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 하면 &lt;strong&gt;./Linux&lt;/strong&gt;에 bin이라는 폴더가 생긴다.&lt;br /&gt;
이제 아래 명령어를 입력하여 nbfc를 opt에 복사/붙여넣기 및 실행해보자.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo mkdir /opt/nbfc

# (자신의 경로)를 입력하자
sudo cp -r ~/(자신의 경로)/nbfc/Linux/bin/Release/* /opt/nbfc/
sudo cp ~/(자신의 경로)/nbfc/Linux/{nbfc.service,nbfc-sleep.service} /etc/systemd/system/

sudo systemctl enable nbfc --now

cd /opt/nbfc
mono nbfc.exe config --apply &quot;아까 Configs에 있던 내 노트북 모델명, 혹은 비슷한 모델명을 입력&quot;

mono nbfc.exe start
mono nbfc.exe status --all
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이를 통해 설치를 완료하였다!&lt;br /&gt;
이 과정은 &lt;a href=&quot;https://github.com/hirschmann/nbfc/wiki/First-steps&quot;&gt;이 링크&lt;/a&gt;에서도 볼 수 있다.&lt;/p&gt;

&lt;p&gt;이제 이놈을 어떻게 사용하냐!&lt;br /&gt;
는 &lt;a href=&quot;https://github.com/hirschmann/nbfc/wiki/Command-line-interface&quot;&gt;이 링크&lt;/a&gt;에 나와 있지만, 뭐 어려울 수 있으니 몇 가지 예시를 아래 써놓았다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 일단 nbfc.exe가 있는 경로에 진입
cd /opt/nbfc/

# 팬 상태 확인하는 법
mono nbfc.exe status -a

# 팬 자동으로 돌리기
mono nbfc.exe set -a

# 팬 속도 조절하기(pwm, 0~100, 100이면 풀파워)
mono nbfc.exe set -s 100
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 정도의 명령어를 자주 쓰게 되는데, 나는 귀찮기 때문에 아래와 같이 ~/.bashrc에 등록해버렸다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/etc/nbfc/bashrc.png&quot; alt=&quot;bashrc&quot; /&gt;&lt;/p&gt;

&lt;p&gt;상당히 편하다…!&lt;/p&gt;

&lt;p&gt;1주일동안 사용해본 결과, 발견 및 생각한 점이 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;내 노트북의 경우, 팬이 2개가 있고 왼쪽이 cpu팬, 오른쪽이 gpu팬인듯 싶은데 이유를 모르겠으나 nbfc를 켜 놓으면 cpu쪽은 항상 돌아가는 반면 gpu쪽은 안돌아갈 때도 있다. pwm을 100으로 맞춰주더라도…&lt;/li&gt;
  &lt;li&gt;아마도, gpu가 많이 필요한 작업이 아닐 때에는 cpu쪽의 팬만 돌려주는 것 같은 느낌이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이번 포스팅은 여기까지다.&lt;/p&gt;

</description>
        <pubDate>2024-03-31</pubDate>
        <link>http://localhost:4000/articles/2023-08/nbfc</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2023-08/nbfc</guid>
        
        <category>blog</category>
        
        <category>블로그</category>
        
        <category>ubuntu</category>
        
        <category>nbfc</category>
        
        <category>fan</category>
        
        <category>노트북</category>
        
        <category>팬</category>
        
        <category>발열</category>
        
        
        <category>etc</category>
        
      </item>
    
      <item>
        <title>C++ 복습</title>
        <description>&lt;h2 id=&quot;c-복습5---복사생성자와-함수중복&quot;&gt;C++ 복습(5) - 복사생성자와 함수중복&lt;/h2&gt;
&lt;h4 id=&quot;c의-객체-복사&quot;&gt;C++의 객체 복사&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;얇은 복사(shallow copy)
    &lt;ul&gt;
      &lt;li&gt;객체 복사시, 객체의 멤버를 1:1로 복사&lt;/li&gt;
      &lt;li&gt;객체의 &lt;strong&gt;사본은 원본 객체가 할당 받은 메모리를 공유함&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;그러므로 원본과 사본중 하나만 수정해도 나머지 객체의 속성이 같이 바뀜&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;깊은 복사(deep copy)
    &lt;ul&gt;
      &lt;li&gt;객체 복사시, 객체의 멤버를 1:1로 복사&lt;/li&gt;
      &lt;li&gt;객체를 그 메모리 크기만큼 아예 다른 객체로 복사하는 것이므로, &lt;strong&gt;원본과 사본이 메모리를 공유하지 않음&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;원본과 사본을 따로 수정 가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;/assets/img/study/cpp/c++_bash_up_5/object_copy.png&quot; alt=&quot;shallow_deep_copy&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;복사-생성자copy-constructor&quot;&gt;복사 생성자(copy constructor)&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;객체를 복사 생성시 호출되는 특별한 생성자&lt;/li&gt;
  &lt;li&gt;특징
    &lt;ul&gt;
      &lt;li&gt;한 클래스에 한개만 선언 가능&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;자기 클래스에 대한 참조 매개변수(class&amp;amp;)&lt;/strong&gt;를 가지는 독특한 생성자&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;복사 생성자 선언 예시
    &lt;ul&gt;
      &lt;li&gt;
        &lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;class Circle {
    ...
    Circle(Circle &amp;amp;c); // 복사 생성자 선언
    ...
}

Circle::Circle(Circle&amp;amp; c){ // 복사 생성자 구현부
    ...
}
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;복사 생성자 사용 예시
    &lt;ul&gt;
      &lt;li&gt;
        &lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;int main() {
    Circle src; // 디폴트 생성자를 사용하여 Circle 객체를 만듦
    Circle dest(src); // dest 객체의 복사 생성자를 호출하여 src객체의 속성을 복사
}
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;복사 생성자가 선언되지 않은 클래스의 경우, 컴파일러가 자동으로 &lt;strong&gt;디폴트 복사 생성자&lt;/strong&gt;를 삽입
    &lt;ul&gt;
      &lt;li&gt;
        &lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;class Circle {  
    int radius;
public:
    Circle(int r);  // 복사 생성자 없음
    double getArea();
}

Circle src(10);
Circle dest(src); // 디폴트 복사 생성자 Circle(Circle&amp;amp;)를 호출  
    
// 디폴트 복사 생성자 예시
Circle::Circle(Circle&amp;amp; c){
    this-&amp;gt;radius = c.radius;
    // 원본 객체 c의 각 멤버를 사본(this)에 복사한다.
}
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;주의할 점&lt;/strong&gt;: 디폴트 복사 생성자의 경우 얕은 복사로 인해 비정상 종료가 일어날 수 있음!!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;얕은 복사로 인한 비정상 종료&lt;/strong&gt; 예시&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;class Person {
    char* name;
    int id;
public:
    Person(int id, const char* name); // 생성자
    ~Person(); // 소멸자
    void changeName(const char *name);
    void show(){ cout &amp;lt;&amp;lt; id &amp;lt;&amp;lt; &apos;,&apos; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; endl;}
};

Person:: Person(int id, const char* name){ // 생성자
    this-&amp;gt;id = id;
    int len = strlen(name); // name의 문자 개수
    this-&amp;gt;name = new char[len+1]; // name의 문자열 공간 동적할당
    strcpy(this-&amp;gt;name, name); // name에 문자열 복사
}
Person::~Pserson(){ // 소멸자
    if(name) // 만일 name에 동적할당된 배열이 있으면
        delete [] name; // 동적할당 메모리 소멸
}
void Person::changeName(const char* name){ // 이름 변경
    if(strlen(name) &amp;gt; strlen(this-&amp;gt;name))
        return;
    strcpy(this-&amp;gt;name, name);
}
// show 객체 구현부는 생략

// 이 부분은 컴파일러에 의해 자동 삽입되는 디폴트 복사 생성자!!
Person::Person(Person&amp;amp; p){
    this-&amp;gt;id = p.id;
    this-&amp;gt;name = p.name;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;int main() {
    Person father(1, &quot;Kitae&quot;);  // (1) father 객체 생성
    Person daughter(father);    // (2) daughter 객체 복사 생성, 복사생성자 호출

    father.show();              // (3) father 객체 출력
    daughter.show();            // (3) daughter 객체 출력

    daughter.changeName(&quot;Grace&quot;); // (4) daughter 이름을 &quot;Grace&quot;로 변경
    
    father.show();              // (5) father 객체 출력
    daughter.show();            // (5) daughter 객체 출력

    return 0;                   // (6), (7) daughter, father 객체 소멸
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;깊은 복사 생성자로 수정&lt;/strong&gt;하여 위에서 발생하는 오류를 해결할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;class Person {
    char* name;
    int id;
public:
    Person(int id, const char* name); // 생성자
    Person(Person&amp;amp; person); // 복사 생성자
    ...
};

Person::Person(Person&amp;amp; person)
{
    this-&amp;gt;id = person.id; //  id값 복사

    // 깊은 복사가 이루어짐
    int len = strlen(person.name); // name의 문자 개수
    this-&amp;gt; name = new char[len + 1]; // name을 위한 공간 할당
    strcpy(this-&amp;gt;name, person.name); // name의 문자열 복사

    cout &amp;lt;&amp;lt; &quot;복사 생성자 실행&quot; &amp;lt;&amp;lt; this-&amp;gt;name &amp;lt;&amp;lt; endl;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;묵시적 복사 생성&lt;/strong&gt; 예제&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;// 2. 값에 의한 호출로 객체가 전달될 때, person 객체의 복사 생성자 호출
void f(Person person){
    person.changeName(&quot;dummy&quot;);
}

Person g(){
    Person mother(2, &quot;Jane&quot;);
    // 3. 함수에서 객체를 리턴할 때, mother 객체의 복사본 생성, 복사본의 복사 생성차 오출
    return mother;
}

int main() {
    Person father(1, &quot;Kitae&quot;);
    // 1. 객체로 초기화하여 객체가 생성될 때, son 객체의 복사 생성자 호출
    Person son = father;
    f(father);
    g();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;함수-중복function-overloading&quot;&gt;함수 중복(Function Overloading)&lt;/h4&gt;
&lt;p&gt;C++에서 코드를 작성하다 보면, C언어와는 다르게 &lt;strong&gt;동일한 이름의 함수가 공존&lt;/strong&gt;할 수 있다. namespace를 분리시키는 방법도 있지만, 여기서의 함수 중복은 그런 것이 아니다.&lt;/p&gt;

&lt;p&gt;단, 함수 중복을 하려면 아래와 같은 조건들을 만족시켜야 한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;중복된 함수들의 이름이 동일해야 한다.&lt;/li&gt;
  &lt;li&gt;중복된 함수들의 매개 변수 타입이 다르거나 개수가 달라야 한다.&lt;/li&gt;
  &lt;li&gt;리턴 타입은 함수 중복과 무관한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;함수 중복을 하게 되면 함수의 이름을 구분하여 기억할 필요가 없고, 함수 호출을 잘못하는 실수를 줄일 수 있다.&lt;/p&gt;

&lt;p&gt;성공적인 함수 중복의 예시는 아래와 같다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;int sum(int a, int b, int c) {
    return a+b+c;
}

double sum(double a, double b) {
    return a+b;
}

int sum(int a, int b) {
    return a+b;
}

int main() {
    // 첫 번째 sum 함수 호출
    cout &amp;lt;&amp;lt; sum(2, 5, 33);

    // 두 번째 sum 함수 호출
    cout &amp;lt;&amp;lt; sum(12.5, 33.6);

    // 세 번째 sum 함수 호출
    cout &amp;lt;&amp;lt; sum(2, 6);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;함수 중복 실패 사례는 아래와 같다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;int sum(int a, b) {
    return a+b;
}

double sum(int a, int b) {
    return (double)(a+b);
}

int main() {
    cout &amp;lt;&amp;lt; sum(s, 5);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 경우 컴파일러는 어떤 sum() 함수를 호출하는지 구분할 수가 없다. 즉, 위에서 언급 한 세 번째 조건에 걸리게 되어 함수 중복에 실패한다. 위 예시와 같은 경우는 차라리 나중에 설명할 generic template 문법을 사용하여 달성할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;생성자-함수-중복&quot;&gt;생성자 함수 중복&lt;/h4&gt;
&lt;p&gt;이전의 게시물에서도 사용한 Circle 예시를 들어서 생성자 함수를 이해해 보자&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;class Circle {
    ...
public:
    Circle() { radius = 1; }
    Circle(int r) { radius = r; }
    ...
}

int main() {
    Circle donut;       // Circle() 생성자 호출
    Circle pizza(30);   // Circle(int r) 생성자 호출
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 처럼 생성자 함수를 중복시킬 수도 있다.&lt;/p&gt;

&lt;h4 id=&quot;디폴트-매개변수&quot;&gt;디폴트 매개변수&lt;/h4&gt;
&lt;p&gt;매개 변수 값이 넘어오지 않는 경우, 디폴트값을 받도록 선언된 매개변수이다.&lt;br /&gt;
&lt;strong&gt;주의 할 점:&lt;/strong&gt; 매개변수가 여러 개인 함수의 경우, 아래와 같이 디폴트값을 받는 매개변수를 함수 선언시 맨 뒤로 위치시켜야 오류가 발생하지 않는다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;void calc(int a, int b=5, int c, int d=0);    // 이 경우 컴파일 오류 발생
void calc(int a, int c, int b=5, int d=0);    // 이렇게 바꿔주면 컴파일 성공
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;함수-중복-간소화&quot;&gt;함수 중복 간소화&lt;/h4&gt;
&lt;p&gt;위에서 설명한 디폴트 매개변수를 사용해서 함수의 중복을 간소화할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;class Circle {
    ...
public:
    Circle() { radius=1; }
    Circle(int r) { radius=r; }
    ...
}

// 위의 중복되는 생성자 함수를 아래와 같이 
// 디폴트 매개변수를 활용하여 간소화시킬 수 있다.
class Circle {
    ...
public:
    Circle(int r=1) { radius=r; }
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;주의할 점:&lt;/strong&gt; 디폴트 매개변수를 가진 함수는 (같은 이름을 가진) 다른 중복함수들과 같이 사용할 수 없다.&lt;/p&gt;

&lt;h4 id=&quot;함수-중복의-모호성&quot;&gt;함수 중복의 모호성&lt;/h4&gt;
&lt;p&gt;함수를 중복할때, 이를 애매하게 작성하면 컴파일러가 어떤 함수를 호출하는지 판단하지 못한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;형 변환으로 인한 모호성&lt;/li&gt;
  &lt;li&gt;
    &lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;float square(float a) {
    return a*a;
}

double square(double a) {
    return a*a;
}

int main() {
    cout &amp;lt;&amp;lt; square(3.0);  // 3.0은 double, 모호하지 않음
    cout &amp;lt;&amp;lt; square(3);    // 3이 double인지, float인지 모호함, 컴파일 오류 발생
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;참조 매개 변수로 인한 모호성
    &lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;int add(int a, int b) {
    return a+b;
}

int add(int a, int &amp;amp;b) {
    b = b+a;
    return b;
}

int main() {
    int s = 10, t = 20;
    cout &amp;lt;&amp;lt; add(s, t); // 값에 의한 호출인지 참조에 의한 호출인지 애매함, 컴파일 오류 발생
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;디폴트 매개 변수로 인한 모호성
    &lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;void msg(int id) {
    cout &amp;lt;&amp;lt; id &amp;lt;&amp;lt; endl;
}

void msg(int id, string s=&quot;&quot;) {
    cout &amp;lt;&amp;lt; id &amp;lt;&amp;lt; &quot;:&quot; &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl;
}

int main() {
    msg(5, &quot;Good Morning&quot;); // 정상 컴파일, 두 번째 msg() 호출
    msg(6); // 디폴트 매개변수를 사용하고 있는지 모호함, 컴파일 오류 발생
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>2024-03-31</pubDate>
        <link>http://localhost:4000/articles/2023-07/C++_bash_up_5</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2023-07/C++_bash_up_5</guid>
        
        <category>c++</category>
        
        <category>코딩테스트</category>
        
        <category>복습</category>
        
        
        <category>study</category>
        
        <category>cpp</category>
        
      </item>
    
      <item>
        <title>C++ 복습</title>
        <description>&lt;h2 id=&quot;c-복습4---함수와-참조&quot;&gt;C++ 복습(4) - 함수와 참조&lt;/h2&gt;
&lt;h4 id=&quot;c의-메모리-종류&quot;&gt;C++의 메모리 종류&lt;/h4&gt;
&lt;p&gt;C++에서, 프로그램 실행을 위한 메모리(RAM)의 영역은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Code
    &lt;ul&gt;
      &lt;li&gt;프로그램 실행코드, 기계어&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Data
    &lt;ul&gt;
      &lt;li&gt;전역변수, 정적변수(static): 프로그램 시작시 할당, 종료시 소멸&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Heap
    &lt;ul&gt;
      &lt;li&gt;메모리 동적할당&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Stack
    &lt;ul&gt;
      &lt;li&gt;지역변수, 매개변수: 함수 호출시 할당, 함수 종료시 소멸&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;함수의-인자-전달-방식&quot;&gt;함수의 인자 전달 방식&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;값에 의한 호출(call by value)
    &lt;ul&gt;
      &lt;li&gt;함수를 호출하는 코드에서 넘어온 &lt;strong&gt;값&lt;/strong&gt;이 매개변수에 &lt;strong&gt;복사&lt;/strong&gt;됨.&lt;br /&gt;
&lt;img src=&quot;/assets/img/study/cpp/c++_bash_up_4/call_by_val.png&quot; alt=&quot;call_by_val&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;주소에 의한 호출(call by address)
    &lt;ul&gt;
      &lt;li&gt;함수를 호출하는 코드에서 넘어온 &lt;strong&gt;주소값&lt;/strong&gt;이 매개변수에 &lt;strong&gt;저장&lt;/strong&gt;됨
&lt;img src=&quot;/assets/img/study/cpp/c++_bash_up_4/call_by_add.png&quot; alt=&quot;call_by_add&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;객체-치환-및-객체-리턴&quot;&gt;객체 치환 및 객체 리턴&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;객체 치환
    &lt;ul&gt;
      &lt;li&gt;동일한 클래스 타입의 객체끼리 치환 가능&lt;/li&gt;
      &lt;li&gt;객체의 모든 데이터가 비트 단위로 복사&lt;/li&gt;
      &lt;li&gt;
        &lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;Circle c1(5);
Circle c2(30);
c1 = c2; // c2 객체를 c1 객체에 비트 단위 복사, c1의 반지름이 30이 됨
// 치환된 두 객체는 내용물은 같지만 공간은 독립적임
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;객체 리턴
    &lt;ul&gt;
      &lt;li&gt;
        &lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;Circle getCircle(){
    Circle tmp(30);
    return tmp; //객체 tmp 리턴
}

Circle c; // c의 반지름 1
c = getCircle(); // tmp 객체의 복사본이 c에 치환, c의 반지름은 30이 됨
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;참조&quot;&gt;참조&lt;/h4&gt;
&lt;p&gt;참조 변수 선언&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;참조자: &lt;strong&gt;&amp;amp;&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;이미 존재하는 변수에 대해 다른 이름(별칭)을 선언
    &lt;ul&gt;
      &lt;li&gt;이름만 다르게 부르며, 같은 메모리 공간을 가리킴&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;참조에 의한 호출(call by reference)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;참조를 가장 많이 활용하는 사례&lt;/li&gt;
  &lt;li&gt;함수의 매개변수를 참조 타입(&amp;amp;)으로 선언
    &lt;ul&gt;
      &lt;li&gt;즉, 함수의 매개변수를 참조 타입으로 받는다면, &lt;strong&gt;함수를 호출하는 부분에서 넣어준 매개변수에 직접 접근해 바로 수정할 수 있게 해준다.&lt;/strong&gt;
&lt;img src=&quot;/assets/img/study/cpp/c++_bash_up_4/call_by_ref.png&quot; alt=&quot;call_by_ref&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;참조 리턴&lt;/strong&gt;
C언어와 다르게 C++의 함수 리턴은&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;값 외에 참조 리턴이 가능하다&lt;/li&gt;
  &lt;li&gt;참조 리턴: 변수 등과 같이 현존하는 공간에 대해 참조 리턴&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;즉 , 참조 리턴은 함수에서 현존하는 공간의 별칭을 리턴한다고 볼 수 있다.&lt;/strong&gt;&lt;br /&gt;
참조 리턴 함수의 예시는 아래와 같다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;char c = &apos;a&apos;;

char&amp;amp; find(){ // char 타입의 참조 리턴
    return c; // 변수 c에 대한 참조 리턴
}

char a = find(); // a = &apos;a&apos;가 됨, a는 c변수의 복사본

char &amp;amp;ref = find(); // find()가 리턴한 공간에 &apos;a&apos; 문자 저장, ref는 c 변수를 참조하게 됨
ref = &apos;M&apos; // c = &apos;M&apos;, ref를 통해 c 변수에 접근하여 그 값을 &apos;M&apos; 문자로 변경

find() = &apos;b&apos;; // find() 함수 호출을 통해 반환된 참조를 통해 c = &apos;b&apos;가 됨
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;사실 참조에 의한 호출 부분은 별로 안헷갈리는데, 참조 리턴 부분이 충분히 헷갈릴 수 있을 것 같다. 이에 주의하면서 복습해야겠다.&lt;/p&gt;

&lt;p&gt;또 다른 간단한 참조 리턴 함수 예시&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;char&amp;amp; find(char s[], index) {
    return s[index];  
    // 배열 s의 index번째 공간에 대한 참조 리턴
}
int main() {
    char name[] = &quot;Mike&quot;;
    cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; endl;

    find(name, 0) = &apos;S&apos;; // name[0] = &apos;S&apos;로 변경
    // name = &quot;Sike
    cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; endl;

    char&amp;amp; ref = find(name, 2);  // 배열 name의 2번째 idx 공간을 ref라 별칭 붙임
    ref = &apos;t&apos; // name = &quot;Site&quot;
    cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; endl;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>2024-03-31</pubDate>
        <link>http://localhost:4000/articles/2023-07/C++_bash_up_4</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2023-07/C++_bash_up_4</guid>
        
        <category>c++</category>
        
        <category>코딩테스트</category>
        
        <category>복습</category>
        
        
        <category>study</category>
        
        <category>cpp</category>
        
      </item>
    
      <item>
        <title>C++ 복습</title>
        <description>&lt;h2 id=&quot;c-복습3---객체의-생성과-사용&quot;&gt;C++ 복습(3) - 객체의 생성과 사용&lt;/h2&gt;

&lt;h3 id=&quot;객체의-생성과-사용&quot;&gt;객체의 생성과 사용&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;포인터로 객체의 멤버를 접근할 때
    &lt;ul&gt;
      &lt;li&gt;객체포인터 &lt;strong&gt;-&amp;gt;&lt;/strong&gt;로 멤버 변수 및 함수에 접근&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예를 들어 아래와 같이 사용할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

class Circle {
    int radius;
public:
    Circle() {radius = 1;}
    Circle(int r) {radius = r;}
    double getArea();
};

double Circle::getArea(){
    return 3.14 * radius * radius;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;클래스가 위와 같다면, 아래와 같이 객체 이름 및 포인터로 멤버 접근이 가능하다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;int main() {
    Circle donut;

    // 객체 이름으로 멤버 접근
    cout &amp;lt;&amp;lt; dounut.getArea() &amp;lt;&amp;lt; endl;

    // 객체 포인터로 멤버 접근
    Circle *p;
    p = &amp;amp;donut;
    cout &amp;lt;&amp;lt; p-&amp;gt;getArea() &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; (*p).getArea() &amp;lt;&amp;lt; endl;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위와 같이, 객체 이름과 ‘,’ 연산자로 직접 멤버에 접근할 수도 있고, 포인터 변수를 만들어서 그 객체 포인터에직접 ‘-&amp;gt;’를 사용하여 접근하거나, (*p)와 ‘.’을 사용해 접근할 수도 있다.&lt;/p&gt;

&lt;h4 id=&quot;객체-배열&quot;&gt;객체 배열&lt;/h4&gt;
&lt;p&gt;위의 Circle 클래스를 조금 수정해서 아래와 같이 바꿨다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

class Circle {
    int radius;
public:
    Circle() {radius = 1;}
    Circle(int r) {radius = r;}
    void setRadius(int r){radius = r;}
    double getArea();
};

double Circle::getArea(){
    return 3.14 * radius * radius;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;객체 배열을 생성하게 되면, 그 초기화는 아래와 같이 이루어질 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;// 배열의 각 원소 객체의 멤버 접근
Circle circleArray[3]; // 기본 생성자 사용, 기본생성자가 없다면 오류 발생

// 멤버 변수 업데이터
circleArray[0].setRadius(10);
circleArray[1].setRadius(20);
circleArray[2].setRadius(30);


// 배열의 각 원소 객체당 생성자를 지정하는 방법
Circle circleArray[3] = {Circle(10), Circle(20), Circle()};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;클래스의 2차원 배열의 경우 아래와 같다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;Circle circles[2][3];

circles[0][0].setRadius(1);
circles[0][1].setRadius(2);
circles[0][2].setRadius(3);
circles[1][0].setRadius(4);
circles[1][1].setRadius(5);
circles[1][2].setRadius(6);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;객체의-동적-할당&quot;&gt;객체의 동적 할당&lt;/h4&gt;
&lt;p&gt;C에서 malloc(), free()를 이용해 메모리를 동적할당 받았다면, C++에서는 &lt;strong&gt;new(), delete()&lt;/strong&gt;연산자로 메모리를 동적 할당 및 반환한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;new 연산자
    &lt;ul&gt;
      &lt;li&gt;기본 타입 메모리 할당, 배열/객체/객체 배열 할당&lt;/li&gt;
      &lt;li&gt;힙 메모리로부터 객체를 위한 메모리 할당 요청&lt;/li&gt;
      &lt;li&gt;객체 할당 생성 시 생성자 호출&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;delete 연산자
    &lt;ul&gt;
      &lt;li&gt;new로 할당받은 메모리 반환&lt;/li&gt;
      &lt;li&gt;소멸자 호출 뒤 객체를 힙에 반환&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예시는 아래와 같다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;데이터타입 *포인터변수 = new 데이터타입;&lt;br /&gt;
delete 포인터변수;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;int *pInt = new int;
char *pChar = new char;
Circle *pCircle = new Circle();

delete pInt;
delete pChar;
delete pCircle;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;동적 할당 시 메모리를 초기화할 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;데이터타입 *포인터변수 = new 데이터타입(초기값);&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;char *pChar = new char(&apos;a&apos;);

// 배열은 동적 할당 시 초기화 불가능
int *pArray = new int[10](20); // 컴파일 오류 발생
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;배열은 delete시 아래와 같이 &lt;strong&gt;’[]’&lt;/strong&gt;를 꼭 써줘야 한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;int *p = new int[10];
delete [] p;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;동적 메모리 할당 시, 메모리 누수를 조심해야 한다. 아래 경우를 통해 확인해보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;char n = &apos;a&apos;;
char *p = new char[1024];
p = &amp;amp;n // p가 n을 가리키면, 기존에 할당받은 1024 바이트의 메모리 누수 발생
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;char *p;
for(int i = 0; i &amp;lt; 100000; i++){
    p = new char[1024];
}
// for문이 돌 때마다, 이전 iteration에서 할당받은 1024 바이트의 메모리 누수 발생
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;프로그램이 종료되면, 운영체제는 누수 메모리를 모두 힙에 반환하긴한다. 하지만, 프로그램을 최적으로 동작시키려면 당연히 실행 중 누수가 발생하지 않도록 해야한다.&lt;/p&gt;

&lt;h4 id=&quot;this-포인터&quot;&gt;this 포인터&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;클래스의 객체를 가리키는 포인터&lt;/li&gt;
  &lt;li&gt;클래스 멤버 함수 내에서만 사용&lt;/li&gt;
  &lt;li&gt;실제 클래스 내의 멤버함수의 경우, 컴파일러가 자동으로 &lt;strong&gt;‘this-&amp;gt;’&lt;/strong&gt;를 앞에 붙여준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;class Circle{
    int radius;
public:
    Circle() {this-&amp;gt;radius=1;}
    Circle(int radius) {this-&amp;gt;radius = radius;}
    void setRadius(int radius) {this-&amp;gt;radius = radius;}
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;멤버 변수와 매개변수의 이름이 같은 경우&lt;/strong&gt; 이를 this로 반드시 구분해서 사용해야 한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;Circle(int radius){
    this-&amp;gt;radius = radius;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;또한 &lt;strong&gt;멤버 함수가 객체 자신의 주소를 리턴할 때&lt;/strong&gt;도 반드시 this가 필요하며, 이는 연산자 중복 시에 매우 필요하다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;class Sample {
public:
    Sample* f() {
        ...
        return this;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;this&lt;/strong&gt;는 사용시 주의할 점이 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;멤버 함수가 아닌 함수에서 this의 사용이 불가하다.&lt;/li&gt;
  &lt;li&gt;static 멤버 함수에서는 this를 사용할 수 없다.
    &lt;ul&gt;
      &lt;li&gt;객체가 생기기 전에 static 함수가 호출될 수도 있기 때문&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>2024-03-31</pubDate>
        <link>http://localhost:4000/articles/2023-07/C++_bash_up_3</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2023-07/C++_bash_up_3</guid>
        
        <category>c++</category>
        
        <category>코딩테스트</category>
        
        <category>복습</category>
        
        
        <category>study</category>
        
        <category>cpp</category>
        
      </item>
    
      <item>
        <title>C++ 복습</title>
        <description>&lt;h2 id=&quot;c-복습2---입출력문자열클래스와-객체&quot;&gt;C++ 복습(2) - 입출력,문자열,클래스와 객체&lt;/h2&gt;

&lt;h3 id=&quot;입출력&quot;&gt;입출력&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;std::cout&lt;/strong&gt; 객체는 &lt;strong&gt;스크린 출력 장치에 연결된 표준 C++ 출력 스트림 객체&lt;/strong&gt;이다.
이는 &amp;lt;iostream&amp;gt; 헤더파일 내에 선언이 되어있으며, namespace std에 선언되어있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;«&lt;/strong&gt; 연산자는 스트림 삽입 연산자로서, &lt;strong&gt;오른쪽 피연산자를 왼쪽 스트림 객체에 삽입&lt;/strong&gt;한다.
이 연산자는 &amp;lt;ostream&amp;gt; 클래스에 구현되어 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;std::cin&lt;/strong&gt;은 &lt;strong&gt;표준 입력 장치인 키보드를 연결하는 C++ 입력 스트림 객체&lt;/strong&gt;이다.
cout과 마찬가지로 &amp;lt;iostream&amp;gt; 헤더파일 내에 선언되어있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;»&lt;/strong&gt; 연산자는 스트림 추출 연산자로, &lt;strong&gt;입력 스트림에서 값을 읽어 오른쪽 변수에 저장&lt;/strong&gt;한다.&lt;/p&gt;

&lt;h3 id=&quot;문자열&quot;&gt;문자열&lt;/h3&gt;
&lt;p&gt;C++의 문자열 표현 방식에는 2가지가 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;C-string 방식(‘\0’으로 끝나는 문자 배열, include &amp;lt;cstring&amp;gt; or &amp;lt;string.h&amp;gt;)
    &lt;ul&gt;
      &lt;li&gt;char name1[6] = {‘G’, ‘r’, ‘a’, ‘c’, ‘e’, ‘\0’}; -&amp;gt; name1은 문자열 “Grace”&lt;/li&gt;
      &lt;li&gt;char name2[5] = {‘G’, ‘r’, ‘a’, ‘c’, ‘e’}; -&amp;gt; name2는 문자열이 아니라 단순 문자 배열&lt;/li&gt;
      &lt;li&gt;
        &lt;string.h&gt; 보다는 &lt;cstring&gt;이 C++ 표준 방식
&lt;/cstring&gt;&lt;/string.h&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;string 클래스 이용(include &amp;lt;string&amp;gt;)
    &lt;ul&gt;
      &lt;li&gt;C++에서 강력 추천, 표준 클래스&lt;/li&gt;
      &lt;li&gt;문자열의 크기에 따른 제약 없음&lt;/li&gt;
      &lt;li&gt;C-string보다 다루기 쉬움&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;istream의 cin.getline()&lt;/strong&gt;&lt;/p&gt;
  &lt;blockquote&gt;
    &lt;p&gt;cin.getline(char str, streamsize n);&lt;br /&gt;
cin.getline(char str, streamsize n, char dlim);&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;공백이 낀 문자열을 입력 받는 방법, delimitChar의 디폴트 값은 ‘\n’&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;string의 getline&lt;/strong&gt;&lt;/p&gt;
  &lt;blockquote&gt;
    &lt;p&gt;getline(istream&amp;amp; is, string str);&lt;br /&gt;
getline(istream&amp;amp; is, string str, char dlim);&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;lt;iostream&amp;gt;, &amp;lt;fstream&amp;gt;, &amp;lt;string&amp;gt;에 정의&lt;/p&gt;

&lt;h3 id=&quot;클래스와-객체&quot;&gt;클래스와 객체&lt;/h3&gt;
&lt;p&gt;클래스 생성자&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;class Circle {
  ...
  Circle();
  Circle(int r);
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위와 같이 한 클래스에서 여러개의 생성자를 중복해서 선언할 수 있다.
생성자를 선언하지 않는다면 기본 생성자가 자동으로 생성된다.(이는 소멸자도 마찬가지이다)&lt;/p&gt;

&lt;h4 id=&quot;위임-생성자&quot;&gt;위임 생성자&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;타겟 생성자: 객체 초기화를 전담하는 생성장&lt;/li&gt;
  &lt;li&gt;위임 생성자: 타겟 생성자를 호출하는 생성자, 객체 초기화를 타겟 생성자에 위임&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;// 위임 생성자
Circle::Circle() : Circle(1) { }

// 타겟 생성자
Circle::Circle(int r){
  radius = r;
  cout &amp;lt;&amp;lt; &quot;반지름 &quot; &amp;lt;&amp;lt; radius &amp;lt;&amp;lt; &quot; 원 생성&quot; &amp;lt;&amp;lt; endl;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;또한 클래스의 멤버 변수는&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;생성자 코드에서 초기화&lt;/li&gt;
  &lt;li&gt;생성자 서두에서 초기값으로 초기화&lt;/li&gt;
  &lt;li&gt;클래스 선언부에서 직접 초기화
가 가능하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;초기값으로 초기화 하는 예시는 아래와 같다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;// 생성자 매개변수가 없을 경우
Point::Point() : x(0), y(0){ }

// 생성자 매개변수가 있을 경우
Point::Point(int a, int b) : x(a), y(b){ }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;접근-지정자&quot;&gt;접근 지정자&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;private&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;동일한 클래스의 멤버 함수에만 제한됨&lt;/li&gt;
      &lt;li&gt;접근 지정자 미 정의시 디폴트값&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;public&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;모든 다른 클래스에 허용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;protected&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;클래스 자신과 상속받은 자식 클래스에만 허용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;인라인-함수&quot;&gt;인라인 함수&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;inline 키워드로 선언된 함수&lt;/li&gt;
  &lt;li&gt;짧은 함수의 경우, 함수를 호출 및 실행하는 오버헤드가 함수를 직접 실행하는 것보다 길기 때문에, 프로그램의 실행 속도 개선을 위해 사용&lt;/li&gt;
  &lt;li&gt;자동 인라인 함수
    &lt;ul&gt;
      &lt;li&gt;클래스 선언부에 구현된 멤버 함수는 컴파일러에 의해 자동으로 inline처리가 된다.&lt;/li&gt;
      &lt;li&gt;클래스 내부의 생성자를 포함한 모든 멤버함수가 자동 인라인 함수로 쓸 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;인라인 함수 사용 예시는 아래와 같다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;#include &amp;lt;iostream&amp;gt;

inline int adder(int a, int b){
  return a + b;
}

int main(void){
  int num;
  num = adder(3, 4);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위의 경우, 앞에 inline 해준 함수를 호출하는 것이 아니라, main문의 코드로 직접 들어가는 것과 같다. 이는 컴파일 과정에서 처리되며, 따라서 짧은 길이의 함수를 반복적으로 실행해야 하는 경우 매우 효율적이다.&lt;/p&gt;
</description>
        <pubDate>2024-03-31</pubDate>
        <link>http://localhost:4000/articles/2023-07/C++_bash_up_2</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2023-07/C++_bash_up_2</guid>
        
        <category>c++</category>
        
        <category>코딩테스트</category>
        
        <category>복습</category>
        
        
        <category>study</category>
        
        <category>cpp</category>
        
      </item>
    
      <item>
        <title>C++ 복습</title>
        <description>&lt;h2 id=&quot;c-복습1---c란&quot;&gt;C++ 복습(1) - C++란?&lt;/h2&gt;
&lt;p&gt;방학동안 여유를 가지고 그동안 헷갈렸던, 또 부족했던 내용들에 대해 복습하려고 한다. 그 첫번째는 C++ 복습이다.&lt;/p&gt;

&lt;p&gt;복습은 온전히 내가 헷갈리거나 강조하고 싶은 내용들 위주로 작성할 것이며, 2학년때 고급프로그래밍 수업을 들은 것을 기반으로 작성한다.&lt;/p&gt;

&lt;p&gt;순전히 나의 복습을 위한 것이기 때문에 두서가 없을 수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;틀리거나 고칠 부분이 있다면 댓글은 환영입니다!&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;c의-표준&quot;&gt;C++의 표준&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1998년 ANSI에서 C++언어에 대한 표준이 설정되었다.&lt;/li&gt;
  &lt;li&gt;연도에 따라 C++98, C++03, …, C++14, C++17, 등으로 표준이 업데이트 되고 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;c의-컴파일러&quot;&gt;C++의 컴파일러&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Borland C++ Compiler&lt;/li&gt;
  &lt;li&gt;Visual C++ Compiler(msvc)&lt;/li&gt;
  &lt;li&gt;GNU C++ Compiler(gcc)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;c언어에-추가된-기능&quot;&gt;C언어에 추가된 기능&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;함수 중복(function overloading)&lt;/li&gt;
  &lt;li&gt;디폴트 매개 변수(default parameter)&lt;/li&gt;
  &lt;li&gt;참조와 참조 변수(reference)&lt;/li&gt;
  &lt;li&gt;참조에 의한 호출(call-by-reference)&lt;/li&gt;
  &lt;li&gt;new/delete 연산자&lt;/li&gt;
  &lt;li&gt;연산자 재정의&lt;/li&gt;
  &lt;li&gt;Gerenic Function &amp;amp; Class&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;빌드-과정&quot;&gt;빌드 과정&lt;/h3&gt;
&lt;p&gt;타 언어와 마찬가지로, &lt;strong&gt;build = compile + link&lt;/strong&gt;이다.
&lt;strong&gt;Compile&lt;/strong&gt;을 통해 &lt;strong&gt;소스 파일을 object(.o, .obj)파일로 변경&lt;/strong&gt;하며, 이렇게 생성된 목적파일에 &lt;strong&gt;linking&lt;/strong&gt; 과정을 통해 &lt;strong&gt;C++ 표준 라이브러리의 함수를 연결 및 실행 파일을 생성&lt;/strong&gt;한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Build = Compile + Link&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;표준-라이브러리&quot;&gt;표준 라이브러리&lt;/h3&gt;
&lt;p&gt;C++의 표준 라이브러리는 &lt;strong&gt;C 라이브러리, C++ 입출력 라이브러리, C++ STL 라이브러리&lt;/strong&gt;의 3개 그룹으로 구분된다.
몇 가지 예시는 아래와 같다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;C 라이브러리
    &lt;ul&gt;
      &lt;li&gt;cassert&lt;/li&gt;
      &lt;li&gt;cmath&lt;/li&gt;
      &lt;li&gt;cstring&lt;/li&gt;
      &lt;li&gt;etc…&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;C++ 입출력 라이브러리
    &lt;ul&gt;
      &lt;li&gt;fstream&lt;/li&gt;
      &lt;li&gt;istream&lt;/li&gt;
      &lt;li&gt;iostream&lt;/li&gt;
      &lt;li&gt;ios&lt;/li&gt;
      &lt;li&gt;etc…&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;C++ STL 라이브러리
    &lt;ul&gt;
      &lt;li&gt;algorithm&lt;/li&gt;
      &lt;li&gt;stack&lt;/li&gt;
      &lt;li&gt;map&lt;/li&gt;
      &lt;li&gt;string&lt;/li&gt;
      &lt;li&gt;etc…&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;C++ 표준 라이브러리에 관한 자세한 내용은 &lt;a href=&quot;https://en.wikipedia.org/wiki/C%2B%2B_Standard_Library&quot;&gt;위키피디아 문서&lt;/a&gt; 또는 &lt;a href=&quot;https://en.cppreference.com/w/cpp/header&quot;&gt;cppreference.com&lt;/a&gt;를 참고하자.&lt;/p&gt;

&lt;p&gt;가독성을 위해서 다음 게시물에 이어서 포스팅할 것이다.&lt;/p&gt;
</description>
        <pubDate>2024-03-31</pubDate>
        <link>http://localhost:4000/articles/2023-07/C++_bash_up_1</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2023-07/C++_bash_up_1</guid>
        
        <category>c++</category>
        
        <category>코딩테스트</category>
        
        <category>복습</category>
        
        
        <category>study</category>
        
        <category>cpp</category>
        
      </item>
    
      <item>
        <title>최근 근황 업데이트</title>
        <description>&lt;h2 id=&quot;오랜만의-근황&quot;&gt;오랜만의 근황&lt;/h2&gt;

&lt;p&gt;우선, 이번 학기동안 캡스톤을 포함하여 총 4개의 전공 프로젝트를 진행하였다. 정말이지 눈코뜰 새 없이 바빴던 것 같다. 다행이도 좋은 팀원들을 만나고, 또 신세를 지기도 하면서 어찌저찌 만족할 만한 결과를 낼 수 있었던 것 같다.&lt;/p&gt;

&lt;p&gt;블로그를 꾸준히 유지보수 하기란 여간 쉬운 일이 아닌 것 같다. 나의 프로젝트 개발 과정과 함께 블로그를 가꾸면 좋겠지만, 각 프로젝트의 기한을 맞추고, 또 교외 활동을 하다보니 꾸준히 블로그를 작성하는 것이 어려웠다.&lt;/p&gt;

&lt;p&gt;이제 조금 여유가 생겼으니, 학기동안 진행한 여러 프로젝트와 현재 진행하고 있는 것들에 대해 시간 되는대로 포스팅해 보고자 한다.&lt;/p&gt;

&lt;p&gt;최근 친구가 해준 조언처럼 여유를 가지되, 꾸준해야겠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/etc/feed_update/ICROS_sea.jpg&quot; alt=&quot;img1&quot; /&gt;
ICROS 2023 학회에 다녀오면서 구경한 바다. 정말 그림처럼 예뻤다.&lt;/p&gt;

&lt;p&gt;열심히 살자!&lt;/p&gt;
</description>
        <pubDate>2024-03-31</pubDate>
        <link>http://localhost:4000/articles/2023-07/feed_update</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2023-07/feed_update</guid>
        
        <category>blog</category>
        
        <category>블로그</category>
        
        
        <category>etc</category>
        
      </item>
    
  </channel>
</rss>
